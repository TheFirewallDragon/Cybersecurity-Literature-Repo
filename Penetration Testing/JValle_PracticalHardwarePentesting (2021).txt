Learn how to pentest your hardware with the most common attract techniques and patterns

Key Features
Explore various pentesting tools and techniques to secure your hardware infrastructure
Protect your hardware by finding potential entry points like glitches
Find the best practices for securely designing your products
Book Description
If you're looking for hands-on introduction to pentesting that delivers, then Practical Hardware Pentesting is for you. This book will help you plan attacks, hack your embedded devices, and secure the hardware infrastructure.

Throughout the book, you will see how a specific device works, explore the functional and security aspects, and learn how a system senses and communicates with the outside world. You'll set up a lab from scratch and then gradually work towards an advanced hardware lab―but you'll still be able to follow along with a basic setup. As you progress, you'll get to grips with the global architecture of an embedded system and sniff on-board traffic, learn how to identify and formalize threats to the embedded system, and understand its relationship with its ecosystem. You'll discover how to analyze your hardware and locate its possible system vulnerabilities before going on to explore firmware dumping, analysis, and exploitation. The reverse engineering chapter will get you thinking from an attacker point of view; you'll understand how devices are attacked, how they are compromised, and how you can harden a device against the most common hardware attack vectors. By the end of this book, you will be well-versed with security best practices and understand how they can be implemented to secure your hardware.

What you will learn
Perform an embedded system test and identify security critical functionalities
Locate critical security components and buses and learn how to attack them Discover how to dump and modify stored information
Understand and exploit the relationship between the firmware and hardware
Identify and attack the security functions supported by the functional blocks of the device
Develop an attack lab to support advanced device analysis and attacks
Who this book is for
If you're a researcher or a security professional who wants a comprehensive introduction into hardware security assessment, then this book is for you. Electrical engineers who want to understand the vulnerabilities of their devices and design them with security in mind will also find this book useful. You won't need any prior knowledge with hardware pentensting before you get started; everything you need is in the chapters.

Table of Contents
Setting Up Your Pentesting Lab and Ensuring Lab Safety
Understanding Your Target
Identifying the Components of Your Target
Approaching and Planning the Test
Our Main Attack Platform
Sniffing and Attacking the Most Common Protocols
Extracting and Manipulating Onboard Storage
Attacking Wi-Fi, Bluetooth, and BLE
Software-Defined Radio Attacks
Accessing the Debug Interfaces
Static Reverse Engineering and Analysis
Dynamic Reverse Engineering
Scoring and Reporting Your Vulnerabilities
Wrapping It Up – Mitigations and Good Practices

p.34 DMM basics
Your DMM will come with a manual. Read it. Even if you have used a multimeter before, 
you have to know the basic characteristics of the tool you will be using.
If you have never used a multimeter, it should come with at least these functions:
• Voltage measure: This will measure the voltage difference between the two test leads. 
If your DMM doesn't have an auto-range function (like most entry-level meters), you 
will have to set the measuring range and set it to direct or alternating voltage.
• Current measure: This will measure the current (the amount of electricity) passing 
through the leads. Again, pay attention to the range. Most of the time, you will have 
to change the connector one of the leads is plugged into (from V to A; sometimes 
there is even a mA connector for lower ranges).
• Resistance measure: This will measure the resistance between leads by creating a 
known voltage between the leads and measuring the current that the resistance lets 
go through. Again, pay attention to the range. The resistance is inferred by using 
Ohm's law:
Voltage (in volts: V) = Resistance (in Ohms: Ω) x Current (in amperes: A).
• Continuity test: When the test leads are connected with a negligible resistance, 
the multimeter will beep.

p.35 The elements to pay attention to when selecting a DMM (in order of priority) are 
the following:
• The DMM really should be of a safety rating compatible with what you are 
measuring (at least CAT III, as you will be measuring main voltages at some point) 
and the probes should be really sharp. In a worst-case scenario, you can always buy 
replacement probes.
• Bandwidth, precision (the number of displayed digits), and the count numbers 
should be as high as your budget allows.
• The speed of the continuity test (try to find review videos)—you want it to be as fast 
as possible.
• The available ranges—you really want as wide a range of measurement as possible, 
both of alternating current (AC) and direct current (DC) (it should range from 
millivolts to at least 1,000 volts; from a few ohms to a few dozens of megaohms; and 
from a few microamps to 10 or 20 amps for current).
• The input impedance (that is, the capability of the meter to read the voltage from 
a circuit without disturbing the circuit)—you want at the very least 10 megaohms 
(the higher the better).
• A serviceable fuse that you can replace easily. 
• Good back-lighting to help with screen visibility when you are working late.

p.37 Here is what to look for in a logic analyzer:
• Sample speed: This is the speed at which the analyzer samples the signal and 
determines the maximum speed of signal you can read accurately. The Nyquist 
criterion tells us that to read a signal accurately, you have to sample it at least at 
twice the speed of the signal. 
• The number of inputs: The higher the better, but you can cover a very large 
percentage of buses with the basic 8-channel analyzers.
• The input protection: You may plug a probe on the wrong thing; you may 
accidentally burn a test system when fiddling with wires; your soldering iron may 
be badly grounded; and more.... There are a thousand things that can kill your 
analyzer; either have spares or good protection.
• The input impedance: Similar to the DMMs—at the very least, 10 megaohms.

p.43 Small tools and equipment
You will need a lot of different small tools in your lab. I personally use multiple mugs and 
boxes to keep them ready near my work area. Some examples are listed here:
• Tweezers: There are different point shapes and quality. You will have a very frequent 
use for sharp pointy ones for very small SMD components (0201, for example) 
and rounded, slightly larger ones for more common packages (0805, for example). 
The lowest-quality ones tend to bend quite easily, and I find that investing in 
medium-quality tweezers can be advantageous. You can find these for quite cheap 
on bidding sites such as eBay.
• Scalpels: I tend to use n°4 medical scalpel handles with detachable blades. They 
replace very advantageously the usual X-ACTO knives (even if the blades are a little 
less sturdy) since the blades are very cheap in packs of 100 and are available in a lot 
of different shapes.
I keep a stock of the following blades:
- n°26: for general cutting work and scrapping traces
- n°23: for cutting work that needs some force and cutting plastic
- n°19: for scrapping traces
• Screwdrivers: You will need a set of long- and thin-precision screwdrivers with 
multiple heads (at least flat, pozidriv, torx, and hex) in multiple sizes. The best 
approach here is to buy a set of screwdrivers with multiple heads and sizes. I would 
also advise that, when you have to buy a set of security bits, you buy one with the 
following: security hex, security torx, tri-wings, tri-groove, pig noses, and clutch 
A and G.
22 Setting Up Your Pentesting Lab and Ensuring Lab Safety
Some vendor-specific and even customer-specific screw/screwdriver couples 
exist, but this can usually be defeated with a bi-component epoxy compound or, 
in extreme cases, with a bit of aluminum casting or computer numerical control
(CNC) machining.
• Clamps: The type of clamps you will be most interested in are called Kelly forceps. 
This type is used to keep things together with a bit of force, like holding boards 
together while soldering or holding wires in place while glue is curing.
• Pliers: You will very often use cutting pliers and long-necked ones to cut leads, 
remove connectors, and for a variety of different tasks. Again, buying decent-quality 
pliers will ensure they can survive small amounts of abuse that is very common in 
regular usage. I would advise investing in a good-quality wire stripper plier (of the 
simplest, flat kind that looks like a pair of pliers with multiple teeth sizes for the 
different wire sizes). I find that self-stripping tools tend to rip and break the cables 
that usually come with embedded systems far too easily.
• Breadboard: A breadboard is a tool where you can plug multiple wires and 
through-hole components temporarily. This is very useful to make small temporary 
circuits to power components and to have some glue logic, level shifting, 
modulation, and so on. You can easily start with cheap breadboards from bidding 
sites but they degrade quite quickly. Better quality brands such as 3M degrade less 
quickly, are a bit expensive, but hold better value over time.
Breadboarded circuits tend to be very fragile due to the way the components are 
mounted. Due to stray capacitance, I would not advise using breadboards with 
frequencies over 5 MHz. The indispensable companions to the breadboard are 
jumper wires (a length of wire with male or female connectors crimped at the end). 
Just find cheap lots of male-male, female-female, and female-male on bidding sites 
and buy some. I consider these consumables since I regularly cut them for ease of 
connection to a breadboard.
• Perfboard/Stripboard: These plates of PCB have either copper dots or strips you 
can cut and solder together in order to create circuits. They are more solid than 
breadboards and behave a bit better at higher frequencies.
• Magnification: As a first step, I recommend buying a few magnifying glasses that 
you can mount on your third hand (if it doesn't come with one already). At a later 
stage, and especially if you are working with very small components (0201 SMD 
or a lot of very fine-pitch MCUs, for example), a stereo microscope is very useful 
to see what you are actually soldering and keep a sense of depth to position your 
iron accurately

p.45 The stock
To start, I would advise keeping the following in stock:
• A collection of common resistors (buy some cheap E12 resistor kit on eBay) in 
through-hole (THT) and surface mount (SMT— a lot in 0805 and a few in 0402).
• A (small) collection of chemical and ceramic capacitor in common values (a 
few in the picofarad range: 0.1µ, 10µ, 47µ mainly, and a few big ones for power 
decoupling). For the packages, same thing as the resistors: a mix of through-hole 
and surface mount.
• A few power (1N4004) and signal (1N4118) diodes. A few Zener diodes for 
common voltage levels won't hurt (5, 3.3, 2.5, 1.8, 1.2). Zener diodes are designed 
to let current flow at a given voltage level, allowing you to protect circuitry against 
voltage spikes or to use them as a crude voltage conversion.
• At least a dozen fixed voltage regulators for the common voltages (5, 3.3, 2.5, 
1.8, 1.2) and a few beefy adjustable ones (LM317 in a TO-220 package is very, 
very useful).
• Some standard transistors (both Field Effect Transistors (FETs) and Bipolar 
Junction Transistors (BJT), again in a mix).
• A few salvaged power supplies that can provide you with 24, 12, and 5 V (the 
powerful USB chargers that come with modern phones will give out a nice stable 
5 V with decent amperage, are plentiful). Power supplies are very common e-waste 
and you can usually score a dozen for a small bill in any flea market... keeping them 
useful and out of the waste pile is both good for your wallet and the planet.
To keep my stock filled and enrich it, my strategy is to always order 10-15% more 
than I need in projects, just to cover the usage and not to have to follow individual 
component use (1 minute of your time is worth more money that the few fractions 
of cent a resistor costs).

p.102 This may be the port that reaches more into your imagination. For each component, 
ask yourself "what if ?" regarding the following:
• Spoofing: Can I pose as this chip (for example, a chip on a board, or a 
sub-processor that is doing DSP)? Can I send fake messages on a communication 
bus? Can I pretend to be the backend or the DNS server?
• Tampering: Can I change the data in that flash? Can I change or replace the code 
that runs on the MCU?
• Repudiation: Can I access the circuitry of a tamper-evident device without leaving 
any trace of this?
• Information leak: Can I read the network traffic? Can I steal keys that are stored 
in an EEPROM?
• Denial of service: Can I make the device crash by sending data or pressing 
buttons randomly? 
• Escalation of privileges: Can I access the management menu? Can I change settings 
without being authorized to?

p.105 Tampering
Tampering: Noun. "Tampering is the action"... Just joking. To tamper with something 
means to change it maliciously. These questions, if answered with yes, all fall into the 
tampering domain:
• Can we change the settings and characteristics that are stored in the Furby?
• Can we change the stored sounds/speech synthesis settings?
• Can we change the Furby's eye patterns?
• Can we make it fully grown/evolved in one go?
Repudiation
To repudiate means to deny being responsible for an action. Since the toy has no concept 
of identity, this does not apply in this context.
Information disclosure
Let's see if we can find out information that we are not supposed to have access to:
• Can we dump internal EEPROMS and find out what information they are storing 
and how?
• Can we abuse the MCU to dump its program?
• Can we sniff ultrasound communication and understand how it works?
Denial of service
Let's see if we can make things unresponsive:
• Can we make the toy crash remotely for good (that is, to manually restart the 
device) or if we sustain our attack?
Escalation of privileges
Let's see if we can do things we are not supposed to be doing:
• Can we run code on the toy MCU?
• Can we run code on the user's phone?
• Can we trigger behaviors we are not supposed to be triggering (for instance, 
laying hundreds of eggs, creating bugged objects, and so on)?
With all of these questions in our mind, let's see how they link to our scenarios by 
learning how to plan the test and discuss its budget with our client.

p.119 The STM32F103C8T6 is a quite capable (32 bits, 72 MHz) microcontroller produced by 
STMicroelectronics that comes with a wide range of typical general-use peripherals:
• Two 12-bit ADCs
• Two I2Cs
• Two SPIs
• Three USARTs
• A USB
• A CAN
• GPIOs
We can now use these to interface with our target systems. Also, in quite practical terms, 
it is possible to program it directly in C (which we will use in the book) or use the 
Arduino IDE and API to program.
Important note
Some vendors are selling boards that have a clone of the STM32F103C8T6 on 
it. These should be fine, but the programming software may complain about it.

p.119 Why C and not Arduino?
The C programming language has a reputation for being hard to use and complex. 
Trust me, it is not. This reputation comes from the fact it doesn't come with a lot of the 
convenience functions of more modern languages. The simplicity that comes with this 
language makes it shine when the resources are constrained and when the execution 
needs to be really efficient, like on a microcontroller!
While I am quite sure that most of the examples in the book could be written using the 
Arduino IDE and API, it would do the following:
• Hide too much of the compilation chain and the programming process from you
• Prevent you from actually understanding the capabilities of the chip
• Make it difficult for you to actually know what is happening on the chip (since it 
uses some of the chip capabilities to provide you with convenience functions)
• Actually consume quite a bit of storage space to provide you with these 
convenience functions

p.151 Mode of operation
First things first, SPI has a frequency. This frequency is determined by the master (which 
is pulsing the clock) and must fall within the max frequency that the currently selected 
peripheral (with a CS wire) supports.
The second thing to take into account with SPI is two parameters called CPOL and CPHA. 
These parameters manage the clock polarity and clock phase:
• Clock Polarity (CPOL) governs the fact that the clock wire is considered active 
high or low.
• Clock Phase (CPHA) governs the timing at which the data will be sampled on the 
adequate wire in respect to the clock cycles.
This creates four "modes" (CPOL and CPHA names are inherited from PIC MCUs but this 
became a de facto standard).

p.155 Understanding UART
UART (otherwise known as RS232 or serial) is a time-based protocol. The data travels on 
two wires.
From the MCU point of view, they are named as follows:
• RX (Receive): The wire on which data comes from the peripheral
• TX (Transmit): The wire on which data goes to the peripheral
The flow control can come in two main flavors:
• With hardware flow control: Two additional control wires control the flow of 
the data. This hardware flow control itself can come in two flavors: either with 
control from the master, CTS (Clear To Send), or from the slave, DTR (Data 
Terminal Ready).
Understanding UART 135
• Without hardware flow control: UART without hardware flow control only takes 
care of "transporting the bits." There is no logic layer to it.
Error detection is also possible in the form of a parity bit added at the end of 
the transmission.
It can connect multiple devices but is not taking care of the addressing (the payload will 
have to take care of this). It also serves as a base of multiple "flavors" of communication 
(IrDA, smartcard communication, and more).

p.185 Basics of networking 
Networking relies on a few basic concepts:
• Encapsulation: Just like a matryoshka doll, network packets behave like a box in a 
box in a box in a... you get the point. The OSI model describes the seven classics layers 
of encapsulation that are potentially present in all communications. For example, it 
is possible to change the physical layer of a packer without impacting the upper layer 
(that is what happens when you send an ethernet frame over Wi-Fi, for example).
• Routing: Routing allows a packet to reach its destination without the sender 
knowing exactly how to get to it or the destination knowing exactly how to send 
the response to the sender. This boils down, in a very oversimplified fashion, to 
each machine knowing how to reach a given number of networks (or groups of 
networks) and having a machine to give packets to when it doesn't know how to 
reach the destination network.
• Connection: A connection is a logical link that's established between two devices, 
where both are aware of the other system being connected to another and of the 
state of data transfer between the two. A well-known protocol that behaves in a 
connected way is TCP (as opposed to UDP, where the connection state is not kept 
by the systems).

p.186 Creating our access point
We will create an access point for the device to connect to.
In terms of Wi-Fi, the device must want/offer the following:
• The device offers a Wi-Fi network of its own
• The device joins a network that we can control
• The device looks for a specific network to join
166 Attacking Wi-Fi, Bluetooth, and BLE
In terms of functionality, the device needs, at the very least, the following:
• DHCP
• DNS
• Routing
Some other services may be needed, depending on the specific device.

p.190 Bluetooth basics
Bluetooth is a radio protocol that operates between 2.4 and 2.48 GHz. It is not easy to sniff 
because it is transmitted by hopping on multiple frequencies pseudorandomly (depending 
on the address of the master device) and has several variants:
• BT/1.x (2000), also known as the ancestor: This has not been deployed in new 
products for a long time. It had privacy problems since it was sending a unique ID 
over the air.
• BT/2.x (2004), also known as classic Bluetooth: This has been around for years 
and is "kind of " kept in the hands of the big players of the market. This is the doing 
of Apple since, to be able to be used by iPhones, you have to send an entry ticket to 
them (called the MFi). It is faster than BT1 and introduces a better pairing system 
and effort in terms of energy consumption.
• BT/3.x (2009), also known as "high speed" (HS): This comes with some (optional) 
hi-speed transfers over Wi-Fi and introduces connection less low latency data 
transfer and some more effort in terms of consumption.
• BTLE/4.x (2010), also known as "Low Energy" or "smart": This actually adds a 
Bluetooth Low Energy (BLE) on top of classic and HS, with a very large reduction 
in terms of power consumption for the BLE part.
• BT5.x (2018): This is the latest version, but it is only supported by some flagship 
phones and a few devices at the moment. Adoption will probably be larger in 
the future.

p.210 Modern embedded devices communicate a lot over radio interfaces in order to be 
independent of cables. It is very common for them to use the well-established protocols 
(such as Wi-Fi or Bluetooth) that we already looked into in previous chapters. There 
are numerous systems that don't need such complex protocols (or are constrained due 
to other design considerations, such as cost, complexity, processing power, and more) 
but still have a need for radio communications. In this case, they tend to use other 
protocols that are not necessarily easy to interface with out of the box. In this case, we 
need to be able to interact with these custom protocols in order to be able to test the 
communication's security. This is the domain of Software-Defined Radio (SDR).

p.212 Understanding and selecting the hardware
As usual, the hardware capabilities and costs are linked. Here is a list of the main domains 
that the hardware selection impacts, with a list of the main SDR adapters and their 
capabilities per domain.
The hardware will mainly define the following:
• The frequencies you can access are as follows:
- RTL-SDR (receive only): 20 MHz–1.75 GHz
- HackRF: 10 MHz–6 GHz
- BladeRF: 300 MHz–3.8 GHz
- USRP: 70 MHz–6 GHz
• The width of the spectrum you can cover in one shot is as follows (the sample rate 
in MS/s is the number of samples it takes per second. It is also the width of the 
spectrum that is captured):
- RTL-SDR: 2.4 MS/s
- HackRF: 20 MS/s
- BladeRF: 40 MS/s
- USRPs: 61 MS/s
The higher the sample rate you have, the faster you can explore the spectrum, but it 
will (most of the time) not impact your capability to analyze signals since most of 
the signals have a bandwidth of a few dozens of KHz in the lower frequencies.
• The price range is as follows:
- RTL-SDR: ~25€
- HackRF: ~300€
- BladeRF: ~400€
- USRPs: ~1,000€+
Once you have decided on your hardware, let's use it to look into a radio device.

p.213 Receiving the signal – a look at antennas
When looking into an antenna to receive your signal, there will be two cases:
• The device emits on a frequency for which commercial antennas are available. Just 
buy an antenna; you can reuse it later and it will be nicely designed, and you won't 
have to worry.
• The device emits on a frequency for which commercial antennas are not available. 
Most of the time, we will be working quite close to the device we will be testing. That 
means we won't need a very performant antenna to be able to receive the signal, but 
we will need something that works at least half-decently in our target band.
Antenna design could cover two or three books on its own (it is a very complex 
domain on its own), their pros and cons too (look into antenna books on your 
favorite bookseller's website if you want confirmation). For our usage, we can just 
use simple, throwaway dipole antennas that I stick to a length of PVC tube, or buy 
a ready-made antenna that matches our frequency range of interest.

p.233 Sending it back
If your hardware supports it, you can record a sample file with a file sink. This can easily 
be played back using your device as a sink instead of a source (file source -> Osmocom 
sink GNU Radio block for hackrf, for example). Just be sure that you are keeping 
the same sampling rate! You can also create modulated signals from Python (or any 
programming language) to send arbitrary signals.
Before sending anything, be sure to check the following:
• Check that it is legal in your country depending on the frequency (on 2.4 GHz, 
it is (https://en.wikipedia.org/wiki/ISM_band) if you respect the 
on-air time).
• That you are not disturbing other receivers around you. Be very wary of the strength 
of the signal you are sending!
You can use a Faraday cage (a metallic container to isolate radio signals) for most of 
your tests by using a discarded microwave (for 2.4 GHz) or find/build one yourself 
for cheap (ammo cans, a big metallic paint pot with a few holes for the cables, and 
more). There are a lot of guides available on the internet.
In order to send back data that you captured (that is, a replay attack), you can use the data 
you captured (from a file source in GNU Radio) and link the output to an appropriate sink.

p.240 Understanding the JTAG protocol
Since JTAG will allow us to debug the chip, it is a very handy attack point. Let's look 
into it.
JTAG is a daisy-chained serial protocol with 4 (or 5) signals:
• TDI (Test Data In): The debug data enters the chip from this signal/pin.
• TDO (Test Data Out): The debug data exits the chip from this signal/pin.
• TCLK (Test CLocK): The serial clock.
• TMS (Test Mode Select): Manages the state of the JTAG engine.
• TRST (Test ReSeT): (optional).

p.254 The adapter file
Let's set up our adapter and our first scan chain by hand so we can understand how the 
configuration files work. First, let's find the required documentation:
• The chip's documentation can be found at this link: https://www.ftdichip.
com/Support/Documents/DataSheets/ICs/DS_FT2232H.pdf.
• Application note for FTDI pins: https://www.ftdichip.com/Support/
Documents/AppNotes/AN_184%20FTDI%20Device%20Input%20
Output%20Pin%20States.pdf.
• Application note for JTAG: https://www.ftdichip.com/Support/
Documents/AppNotes/AN_129_FTDI_Hi_Speed_USB_To_JTAG_
Example.pdf.
• The adapter setup file documentation can be found at this link: http://
openocd.org/doc/html/Debug-Adapter-Configuration.html.
That's a lot! So, let's have a look at a real setup to understand how it works. The mode used 
for JTAG is called MPSSE, it is used for SPI-style interfaces. In the pin description file, we 
can see, in MPSSE, the following:
• ADBUS0 or BDBUS0: TCK
• ADBUS1 or BDBUS1: TDI
• ADBUS2 or BDBUS2: TDO
• ADBUS3 or BDBUS3: TMS

p.309 General information and syntax
Here is some general information about the ARM architecture. You have to keep this in 
mind when reading ARM assembly code:
• Instructions come in two flavors: ARM (four byte instructions) and thumb (either 
two or four instructions). The last bit of the PC register (the program counter, 
holds the address of the current instruction) is used to indicate whether the 
instruction mode is thumb or ARM in the CPUs that support both (0 means ARM, 
1 means thumb). This means that the instructions have to be memory-aligned to at 
least two bytes for thumb mode (due to the last address bit being used for the mode) 
and four bytes for ARM mode.
• (Most) ARM chips support both a big-endian and little-endian operating mode.
• ARM chips have a barrel register for operands, making it easy to bit-shift operands 
and operate on them in a single instruction.
• Most instructions come with conditional forms (that is, they will only be executed 
if certain status flags are set) and sized forms (to indicate on what part of the target/
source registers/address it applies to) and can be suffixed with s to indicate that 
the Current Program Status Register (CPSR) must be updated. Look into how an 
ARM or thumb instruction is encoded if you want more details (http://www.
csbio.unc.edu/mcmillan/Comp411F18/Lecture06.pdf).
• The architectures have multiple versions and not all instructions are available on 
all versions. See https://www.cs.umd.edu/~meesh/cmsc411/website/
proj01/arm/armchip.html and the architecture manuals relevant to your 
architecture version of interest.
• The architectures (depending on the version) are sometimes available in 32-bit 
(AARCH32) and 64-bit (AARCH64) flavors. The 64-bit version is available starting 
with the ARMv8 ISA.

p.318 First Ghidra inspection
At first glance, the main function looks very similar to the main function in the previous 
chapter. We can find the reference to the main function by searching a PASSWORD string 
just like in the previous chapter and look into analyzing its structure.
I will let you work on the skills you acquired in the previous chapter to find the different 
functions. In this executable, you will find the following again:
• A big while (true) loop that acts as the main event loop and blinks the bluepill's 
LED while acting on a password being entered
• A function to initialize the clock
• A function to initialize the GPIOs
• A function to initialize the UART
• A value depending on the chip's unique identifier is calculated again in almost the 
same way (calculate this value for your chip and note this value down)
• A function validates the password (just before a big if that triggers either the 
printing of YOU WIN or NO)
• A function decrypts the winning string if the validation function returns an 
(uint16_t ) 0 value.
The similarity of the structure is intentional as this is your first time. If I were to repeat 
the exact same steps as in the previous chapter, it wouldn't give you anything new to 
learn, right?
Now, let's go through multiple methods of bypassing this password validation through 
dynamic interaction with the system. We will go from the most complex to the simplest in 
order to keep you focused and acquiring know-how (if you are anything like me, if there is 
an easy way to bypass something, why go for the hard way?).

p.334 The actual impact has to be discussed in advance with the client. It is very clear that 
an SME and a giant, multinational group will cope with a financial impact in a very 
different way. For example, the big fish will probably have a lot more financial resources 
than an SME but could be far more sensitive to reputational risk (stock valuation impact 
and so on).
When agreeing on an impact scale with a client, the following impact dimensions have to 
be considered:
• Financial loss: Direct or through missed opportunities.
• Legal risk: With special attention to the fact that multiple legal frameworks and 
punishments may be of concern:
- Privacy laws: Especially if European citizens are concerned.
- Environmental laws 
- Consumer protection laws: But explicitly exclude safety and electromagnetic 
disturbance laws – these are highly specialized.
- Loss of life or "organic damage": Bodies getting cold on the floor can cost a pretty 
penny and be terribly bad for the company's image.
- Contractual risk: Could the company be sued by consumers or other companies 
due to the contract in place?
- Other specific regulations...
• Reputational risk: The company image at large. Do you want to run the risk of 
being seen as selling bad quality products?
• Operational risk: Could the company infrastructure and resources be impacted by 
the vulnerability in a way that would compromise its normal operations?
• Strategic risk: Will the vulnerability: Allow the product to be duplicated or faked 
by a third party? Disrupt the financial model of the service? Provide an unfair 
advantage to a competitor? Leak proprietary processes?
For each of the identified risks, the client will have to agree on its relevance and their 
perception of the risk's scale. This perception can vary widely from client to client. For 
example, an SME could see losing a million dollars as critical while a multinational 
company could score this as medium. This can also vary widely between companies 
depending on their risk appetite.


p.344 Now we have found a lot of vulnerabilities, stolen secrets, and disturbed and intercepted 
communications, but how do we wrap up the story for our clients? How do we link this 
to existing industry good practices and how do we advise our clients in order for them to 
realize that they are not the only ones making these mistakes and, more importantly, on 
how to fix them? And, since this is the last chapter of the book, what do you do next and 
what kinds of things could you look into to satisfy your curiosity for research?
In order to advise your client on how to solve the problems you found, we will look into 
the sources you can rely on to relate your findings to good practices (basically to tell your 
client that their security is bad, and they should feel bad), then quick solutions to common 
problems, and, in the end, how you can continue bettering yourself at hardware.

p.348 The CIS benchmarks
The CIS benchmarks are a whole family of baselines and indicators that you can draw 
inspiration from when evaluating a device, more specifically, the diverse components 
of its firmware. You will find a whole bunch of best practices here that can be applied to 
embedded Linux systems, web servers, and so on.
Here is a (short) list of the ones I personally use the most when reporting on the security 
level of an embedded system:
• Distribution-independent Linux
• Google Android
• Apache HTTP Server
• Printer devices (even when not talking about a printer, these have interesting points 
if you are testing for a potential user of the device and not necessarily the vendor of 
the device)
• Not everything is necessary relevant but these may be of interest if the device is 
talking to them (especially to upsell other testing services if your company has 
the capabilities): Amazon, Alibaba, Azure, and Google Cloud Platform
This is a lot of information to consider, so I sincerely invite you to peruse them so that you 
can reference them in your reporting, if relevant.

p.353 Here is a list of things you can play with for cheap:
• Old routers, modems, and telecom equipment in general: They are super easy to 
find discarded in an office corner or at a flea market. They usually run some kind 
of embedded operating system and you may find some things you are not used to 
(VxWorks, Windows CE, Symbian, and so on) and "weird" architectures (8086, Z80, 
68k, PPC, MIPS, and so on).
• Old toys: If you destroy an old toy that you bought for €1 at your local flea market, 
you won't care! This means that you will actually learn a lot. Even when destroying 
it you will learn (of course, you have to investigate on how you actually did it). 
Another upside of old toys is that, since they're built to a price, they use big 
components (but also epoxy blobs)!
- Musical ones: Not only is circuit bending to make them play strange noises very 
fun in itself (look at the "Look mum no computer" YouTube channel for basic 
electronics and circuit bending tip and tricks) but this is actually a good way to 
learn more about the analog part of the circuits, the basic operation of transistors 
and all.
- Educational toys (such as spelling toys and kid's computers): These are 
especially interesting to play with for extracting EEPROMs, training yourself at 
reversing storage formats, extracting and replacing strings, and so on.
- Radio-guided cars: These are great for studying and reversing specific radio 
protocols (also, the commands are usually legal to send back even without a license).
• Old mobile phones (like really old ones) to get a sense of modern construction, 
small SMD components, and so on.
• Cheap IoT things such as connected doorbells, thermostats, 3/4G gateways, and 
so on
